#!/usr/bin/env bash

################################################################################

IFS= read -rd '' workdir < <(dirname -z -- "$0")
IFS= read -rd '' workdir < <(readlink -e -z -- "$workdir")
# Path to 'resume' script
RESUME=$workdir/resume
if ! [[ -x $RESUME ]]; then
    echo >&2 "E: '$RESUME' is not an executable file."
    exit 1
fi
# Number of tests
TESTS_N=$(grep -c '^check ' -- "$0") || exit "$?"
# Fake $MPV to pass to $RESUME
FAKE_MPV='printf %s\0'
# Fake $HOME to pass to $RESUME
FAKE_HOME=$(mktemp -d) || exit "$?"
# $RESUME's output file
OUTFILE=$FAKE_HOME/out
# “0” if test failed, “1” if succeeded
TEST_RESULTS=()
# Current test number (0 … TESTS_N-1)
CURRENT_TEST=0
# Current test's root
unset CURRENT_ROOT

################################################################################

_on_exit() {
    trap - EXIT
    rm -rf -- "$FAKE_HOME" "$CURRENT_ROOT"
    if (( CURRENT_TEST == TESTS_N )); then
        local -i i failed=0
        for (( i = 0; i < TESTS_N; ++i )); do
            (( TEST_RESULTS[i] == 0 && failed++ ))
        done
        if (( failed )); then
            echo " *** ${failed} test(s) failed ***"
            exit 1
        else
            echo " *** everything is OK ***"
            exit 0
        fi
    else
        echo >&2 " *** fatal error occured ***"
        exit 1
    fi
}

trap '_on_exit' EXIT

################################################################################

RED=$'\e[0;1;31m'
GREEN=$'\e[0;1;32m'
BOLD=$'\e[0;1m'
RESET=$'\e[0m'

################################################################################

_check_before() {
    if [[ -n ${TEST_RESULTS[$CURRENT_TEST]} ]]; then
        echo >&2 "E: test #$((CURRENT_TEST+1)) called fail()/success() twice."
        exit
    fi
}

_check_after() {
    if [[ -z ${TEST_RESULTS[$CURRENT_TEST]} ]]; then
        echo >&2 "E: test #$((CURRENT_TEST+1)) called neither fail() nor success()."
        exit
    fi
}

_tell() {
    echo >&2 "$BOLD$((CURRENT_TEST+1))/$TESTS_N$2 $1$BOLD: $3$RESET"
}

fail() {
    _check_before
    TEST_RESULTS[$CURRENT_TEST]=0
    _tell FAILED "$RED" "$*"
}

success() {
    _check_before
    TEST_RESULTS[$CURRENT_TEST]=1
    _tell SUCCEED "$GREEN" "$*"
}

check() {
    _check "$@"
    rm -rf -- "$CURRENT_ROOT" || exit
    _check_after
    (( CURRENT_TEST++ ))
}

# USAGE: _check [-v] [-a <resume args>] [-c <rcfile content>] [--] <files> [// <expected files>]
# Default <expected files> are <files>.
# OPTIONS:
#     -v: check that resume fails
#     -a: specify arguments to pass to resume (separate by $IFS)
#     -c: specify fake ~/.resumerc content
_check() {
    CURRENT_ROOT=$(mktemp -d) || return "$?"
    cd "$CURRENT_ROOT" || return "$?"

    local config_content=
    local check_fail=0
    local -a args
    local -a expected

    local option OPTIND OPTARG
    while getopts 'va:c:' option; do
        case "$option" in
            v) check_fail=1 ;;
            a) args=( $OPTARG ) ;;
            c) config_content=$OPTARG ;;
            *) echo >&2 "E: wrong check() usage"; return 2 ;;
        esac
    done
    shift "$(( OPTIND - 1 ))" || return "$?"

    expected=( "$@" )

    while (( $# )); do
        if [[ $1 == // ]]; then
            expected=( "${@:2}" )
            expected=( "${expected[@]//%root%/"$CURRENT_ROOT"}" )
            break
        elif [[ $1 == */ ]]; then
            mkdir -p -- "$1" || return "$?"
        else
            if [[ $1 == */* ]]; then
                local dir
                IFS= read -rd '' dir < <(dirname -z -- "$1")
                if ! [[ -d $dir ]]; then
                    mkdir -p -- "$dir" || return "$?"
                fi
            fi
            touch -- "$1" || return "$?"
        fi
        shift
    done

    cat > "$FAKE_HOME"/.resumerc <<EOF || return "$?"
MPV_OPTS=()
$config_content
EOF

    if (( check_fail )); then
        local stderr=/dev/null
    else
        local stderr=/dev/stderr
    fi
    HOME=$FAKE_HOME MPV=$FAKE_MPV "$RESUME" "${args[@]}" >"$OUTFILE" 2>"$stderr"
    local code=$?

    if (( check_fail )); then
        if (( code == 0 )); then
            fail "-v passed, but exited with code 0"
            return
        else
            success "OK exit code $code (-v passed)"
            return
        fi
    elif (( code != 0 )); then
        fail "exited with code $code (-v not passed)"
        return
    fi

    local found
    while IFS= read -rd '' found; do
        if (( !${#expected[@]} )); then
            fail "found but not expected '$found'"
            return
        fi
        if [[ ${expected[0]} != $found ]]; then
            fail "expected '${expected[0]}' found '$found'"
            return
        fi
        expected=( "${expected[@]:1}" )
    done < "$OUTFILE"

    if (( ${#expected[@]} )); then
        fail "expected but not found '${expected[0]}'"
        return
    fi

    success "OK everything matches"
}

################################################################################

check -- {1,2,3}.mkv {a,b,c}.mkv {а,б,в}.mkv

check -a'-n' file-without-numbers.mkv z1.mkv aaa2.mkv
check -a'-n' number-in-extension.mp4 {0,2,12,9999}.mkv
check -a'-n' {01..10}.mkv
check -a'-n' -c'NON_NUMBERS=("+([0-9])")' season1_ep{1,12}.mkv

check -v
check -v sound.mp3 unrelated-file

check        file.mkv foo/file.mkv // file.mkv
check -a'-r' file.mkv foo/file.mkv

check -a'-rn' season{1,12}/episode{1,12}.mkv

check -- --some-option=arg.mkv // %root%/--some-option=arg.mkv

check -a'-s' foo.ass foo.mkv           // foo.mkv
check -a'-s' subs/foo.ass foo.mkv      // --sub-paths=subs foo.mkv
check -a'-s' subs{1,2}/foo.ass foo.mkv // --sub-paths=subs2:subs1 foo.mkv

check -a'-S' baz1.ass foo1.ass bar1.mkv           // --\{ --sub-file=baz1.ass --sub-file=foo1.ass bar1.mkv --\}
check -a'-S' no-number.ass no-number.mkv          // no-number.mkv
check -a'-rS' root1.ass foo/bar1.ass foo/baz1.mkv // --\{ --sub-file=foo/bar1.ass foo/baz1.mkv --\}

check -a'-a' bar.mkv bar.mp3     // bar.mkv
check -a'-a' bar.mkv foo/bar.mp3 // --\{ --audio-file=foo/bar.mp3 bar.mkv --\}
